{"ast":null,"code":"import _regeneratorRuntime from\"/Users/josephsamir/Desktop/Users/react-userscripts/userscript/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/josephsamir/Desktop/Users/react-userscripts/userscript/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/**\n * Wrapped console.log function.\n *\n * @export\n * @param {*} args\n */export function log(){var _console;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}(_console=console).log.apply(_console,[\"Userscript (React Mode):\"].concat(args));}/**\n * Wrapped version of `fetch` that logs the output as it's being fetched.\n * It also specifies the full path, because in Greasemonkey, the full path is needed.\n *\n * @param {string} arg\n * @returns {Promise} - the `fetch` promise\n */export function logFetch(arg){var url=new URL(arg,window.location);log(\"fetching\",\"\"+url);return fetch(\"\"+url,{credentials:\"include\"});}/**\n * Ensure `callback` is called every time window.location changes\n * Code derived from https://stackoverflow.com/questions/3522090/event-when-window-location-href-changes\n *\n * @export\n * @param {function} callback - function to be called when URL changes\n * @returns {MutationObserver} - MutationObserver that watches the URL\n */export function addLocationChangeCallback(callback){// Run the callback once right at the start\nwindow.setTimeout(callback,0);// Set up a `MutationObserver` to watch for changes in the URL\nvar oldHref=window.location.href;var body=document.querySelector(\"body\");var observer=new MutationObserver(function(mutations){if(mutations.some(function(){return oldHref!==document.location.href;})){oldHref=document.location.href;callback();}});observer.observe(body,{childList:true,subtree:true});return observer;}/**\n * Awaits for an element with the specified `selector` to be found\n * and then returns the selected dom node.\n * This is used to delay rendering a widget until its parent appears.\n *\n * @export\n * @param {string} selector\n * @returns {DOMNode}\n */export function awaitElement(_x){return _awaitElement.apply(this,arguments);}function _awaitElement(){_awaitElement=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(selector){var MAX_TRIES,tries;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:MAX_TRIES=60;tries=0;return _context.abrupt(\"return\",new Promise(function(resolve,reject){function probe(){tries++;return document.querySelector(selector);}function delayedProbe(){if(tries>=MAX_TRIES){log(\"Can't find element with selector\",selector);reject();return;}var elm=probe();if(elm){resolve(elm);return;}window.setTimeout(delayedProbe,250);}delayedProbe();}));case 3:case\"end\":return _context.stop();}}},_callee);}));return _awaitElement.apply(this,arguments);}","map":{"version":3,"sources":["/Users/josephsamir/Desktop/Users/react-userscripts/userscript/src/utils.js"],"names":["log","args","console","logFetch","arg","url","URL","window","location","fetch","credentials","addLocationChangeCallback","callback","setTimeout","oldHref","href","body","document","querySelector","observer","MutationObserver","mutations","some","observe","childList","subtree","awaitElement","selector","MAX_TRIES","tries","Promise","resolve","reject","probe","delayedProbe","elm"],"mappings":"qWAAA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASA,CAAAA,GAAT,EAAsB,4CAANC,IAAM,0CAANA,IAAM,wBACzB,UAAAC,OAAO,EAACF,GAAR,iBAAY,0BAAZ,SAA2CC,IAA3C,GACH,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASE,CAAAA,QAAT,CAAkBC,GAAlB,CAAuB,CAC1B,GAAMC,CAAAA,GAAG,CAAG,GAAIC,CAAAA,GAAJ,CAAQF,GAAR,CAAaG,MAAM,CAACC,QAApB,CAAZ,CACAR,GAAG,CAAC,UAAD,CAAa,GAAKK,GAAlB,CAAH,CACA,MAAOI,CAAAA,KAAK,CAAC,GAAKJ,GAAN,CAAW,CAAEK,WAAW,CAAE,SAAf,CAAX,CAAZ,CACH,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASC,CAAAA,yBAAT,CAAmCC,QAAnC,CAA6C,CAChD;AACAL,MAAM,CAACM,UAAP,CAAkBD,QAAlB,CAA4B,CAA5B,EAEA;AACA,GAAIE,CAAAA,OAAO,CAAGP,MAAM,CAACC,QAAP,CAAgBO,IAA9B,CACA,GAAMC,CAAAA,IAAI,CAAGC,QAAQ,CAACC,aAAT,CAAuB,MAAvB,CAAb,CACA,GAAMC,CAAAA,QAAQ,CAAG,GAAIC,CAAAA,gBAAJ,CAAqB,SAAAC,SAAS,CAAI,CAC/C,GAAIA,SAAS,CAACC,IAAV,CAAe,iBAAMR,CAAAA,OAAO,GAAKG,QAAQ,CAACT,QAAT,CAAkBO,IAApC,EAAf,CAAJ,CAA8D,CAC1DD,OAAO,CAAGG,QAAQ,CAACT,QAAT,CAAkBO,IAA5B,CACAH,QAAQ,GACX,CACJ,CALgB,CAAjB,CAOAO,QAAQ,CAACI,OAAT,CAAiBP,IAAjB,CAAuB,CAAEQ,SAAS,CAAE,IAAb,CAAmBC,OAAO,CAAE,IAA5B,CAAvB,EACA,MAAON,CAAAA,QAAP,CACH,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,eAAsBO,CAAAA,YAAtB,iD,+FAAO,iBAA4BC,QAA5B,sIACGC,SADH,CACe,EADf,CAECC,KAFD,CAES,CAFT,iCAGI,GAAIC,CAAAA,OAAJ,CAAY,SAACC,OAAD,CAAUC,MAAV,CAAqB,CACpC,QAASC,CAAAA,KAAT,EAAiB,CACbJ,KAAK,GACL,MAAOZ,CAAAA,QAAQ,CAACC,aAAT,CAAuBS,QAAvB,CAAP,CACH,CAED,QAASO,CAAAA,YAAT,EAAwB,CACpB,GAAIL,KAAK,EAAID,SAAb,CAAwB,CACpB5B,GAAG,CAAC,kCAAD,CAAqC2B,QAArC,CAAH,CACAK,MAAM,GACN,OACH,CACD,GAAMG,CAAAA,GAAG,CAAGF,KAAK,EAAjB,CACA,GAAIE,GAAJ,CAAS,CACLJ,OAAO,CAACI,GAAD,CAAP,CACA,OACH,CAED5B,MAAM,CAACM,UAAP,CAAkBqB,YAAlB,CAAgC,GAAhC,EACH,CAEDA,YAAY,GACf,CAtBM,CAHJ,wD","sourcesContent":["/**\n * Wrapped console.log function.\n *\n * @export\n * @param {*} args\n */\nexport function log(...args) {\n    console.log(\"Userscript (React Mode):\", ...args);\n}\n\n/**\n * Wrapped version of `fetch` that logs the output as it's being fetched.\n * It also specifies the full path, because in Greasemonkey, the full path is needed.\n *\n * @param {string} arg\n * @returns {Promise} - the `fetch` promise\n */\nexport function logFetch(arg) {\n    const url = new URL(arg, window.location);\n    log(\"fetching\", \"\" + url);\n    return fetch(\"\" + url, { credentials: \"include\" });\n}\n\n/**\n * Ensure `callback` is called every time window.location changes\n * Code derived from https://stackoverflow.com/questions/3522090/event-when-window-location-href-changes\n *\n * @export\n * @param {function} callback - function to be called when URL changes\n * @returns {MutationObserver} - MutationObserver that watches the URL\n */\nexport function addLocationChangeCallback(callback) {\n    // Run the callback once right at the start\n    window.setTimeout(callback, 0);\n\n    // Set up a `MutationObserver` to watch for changes in the URL\n    let oldHref = window.location.href;\n    const body = document.querySelector(\"body\");\n    const observer = new MutationObserver(mutations => {\n        if (mutations.some(() => oldHref !== document.location.href)) {\n            oldHref = document.location.href;\n            callback();\n        }\n    });\n\n    observer.observe(body, { childList: true, subtree: true });\n    return observer;\n}\n\n/**\n * Awaits for an element with the specified `selector` to be found\n * and then returns the selected dom node.\n * This is used to delay rendering a widget until its parent appears.\n *\n * @export\n * @param {string} selector\n * @returns {DOMNode}\n */\nexport async function awaitElement(selector) {\n    const MAX_TRIES = 60;\n    let tries = 0;\n    return new Promise((resolve, reject) => {\n        function probe() {\n            tries++;\n            return document.querySelector(selector);\n        }\n\n        function delayedProbe() {\n            if (tries >= MAX_TRIES) {\n                log(\"Can't find element with selector\", selector);\n                reject();\n                return;\n            }\n            const elm = probe();\n            if (elm) {\n                resolve(elm);\n                return;\n            }\n\n            window.setTimeout(delayedProbe, 250);\n        }\n\n        delayedProbe();\n    });\n}\n"]},"metadata":{},"sourceType":"module"}