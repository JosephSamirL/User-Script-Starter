{"ast":null,"code":"/**\n * Wrapped console.log function.\n *\n * @export\n * @param {*} args\n */\nexport function log(...args) {\n  console.log(\"Userscript (React Mode):\", ...args);\n}\n/**\n * Wrapped version of `fetch` that logs the output as it's being fetched.\n * It also specifies the full path, because in Greasemonkey, the full path is needed.\n *\n * @param {string} arg\n * @returns {Promise} - the `fetch` promise\n */\n\nexport function logFetch(arg) {\n  const url = new URL(arg, window.location);\n  log(\"fetching\", \"\" + url);\n  return fetch(\"\" + url, {\n    credentials: \"include\"\n  });\n}\n/**\n * Ensure `callback` is called every time window.location changes\n * Code derived from https://stackoverflow.com/questions/3522090/event-when-window-location-href-changes\n *\n * @export\n * @param {function} callback - function to be called when URL changes\n * @returns {MutationObserver} - MutationObserver that watches the URL\n */\n\nexport function addLocationChangeCallback(callback) {\n  // Run the callback once right at the start\n  window.setTimeout(callback, 0); // Set up a `MutationObserver` to watch for changes in the URL\n\n  let oldHref = window.location.href;\n  const body = document.querySelector(\"body\");\n  const observer = new MutationObserver(mutations => {\n    if (mutations.some(() => oldHref !== document.location.href)) {\n      oldHref = document.location.href;\n      callback();\n    }\n  });\n  observer.observe(body, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n/**\n * Awaits for an element with the specified `selector` to be found\n * and then returns the selected dom node.\n * This is used to delay rendering a widget until its parent appears.\n *\n * @export\n * @param {string} selector\n * @returns {DOMNode}\n */\n\nexport async function awaitElement(selector) {\n  const MAX_TRIES = 60;\n  let tries = 0;\n  return new Promise((resolve, reject) => {\n    function probe() {\n      tries++;\n      return document.querySelector(selector);\n    }\n\n    function delayedProbe() {\n      if (tries >= MAX_TRIES) {\n        log(\"Can't find element with selector\", selector);\n        reject();\n        return;\n      }\n\n      const elm = probe();\n\n      if (elm) {\n        resolve(elm);\n        return;\n      }\n\n      window.setTimeout(delayedProbe, 250);\n    }\n\n    delayedProbe();\n  });\n}","map":{"version":3,"sources":["/Users/josephsamir/Desktop/Users/react-userscripts/userscript/src/utils.js"],"names":["log","args","console","logFetch","arg","url","URL","window","location","fetch","credentials","addLocationChangeCallback","callback","setTimeout","oldHref","href","body","document","querySelector","observer","MutationObserver","mutations","some","observe","childList","subtree","awaitElement","selector","MAX_TRIES","tries","Promise","resolve","reject","probe","delayedProbe","elm"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,GAAT,CAAa,GAAGC,IAAhB,EAAsB;AACzBC,EAAAA,OAAO,CAACF,GAAR,CAAY,0BAAZ,EAAwC,GAAGC,IAA3C;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,QAAT,CAAkBC,GAAlB,EAAuB;AAC1B,QAAMC,GAAG,GAAG,IAAIC,GAAJ,CAAQF,GAAR,EAAaG,MAAM,CAACC,QAApB,CAAZ;AACAR,EAAAA,GAAG,CAAC,UAAD,EAAa,KAAKK,GAAlB,CAAH;AACA,SAAOI,KAAK,CAAC,KAAKJ,GAAN,EAAW;AAAEK,IAAAA,WAAW,EAAE;AAAf,GAAX,CAAZ;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,yBAAT,CAAmCC,QAAnC,EAA6C;AAChD;AACAL,EAAAA,MAAM,CAACM,UAAP,CAAkBD,QAAlB,EAA4B,CAA5B,EAFgD,CAIhD;;AACA,MAAIE,OAAO,GAAGP,MAAM,CAACC,QAAP,CAAgBO,IAA9B;AACA,QAAMC,IAAI,GAAGC,QAAQ,CAACC,aAAT,CAAuB,MAAvB,CAAb;AACA,QAAMC,QAAQ,GAAG,IAAIC,gBAAJ,CAAqBC,SAAS,IAAI;AAC/C,QAAIA,SAAS,CAACC,IAAV,CAAe,MAAMR,OAAO,KAAKG,QAAQ,CAACT,QAAT,CAAkBO,IAAnD,CAAJ,EAA8D;AAC1DD,MAAAA,OAAO,GAAGG,QAAQ,CAACT,QAAT,CAAkBO,IAA5B;AACAH,MAAAA,QAAQ;AACX;AACJ,GALgB,CAAjB;AAOAO,EAAAA,QAAQ,CAACI,OAAT,CAAiBP,IAAjB,EAAuB;AAAEQ,IAAAA,SAAS,EAAE,IAAb;AAAmBC,IAAAA,OAAO,EAAE;AAA5B,GAAvB;AACA,SAAON,QAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeO,YAAf,CAA4BC,QAA5B,EAAsC;AACzC,QAAMC,SAAS,GAAG,EAAlB;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC,aAASC,KAAT,GAAiB;AACbJ,MAAAA,KAAK;AACL,aAAOZ,QAAQ,CAACC,aAAT,CAAuBS,QAAvB,CAAP;AACH;;AAED,aAASO,YAAT,GAAwB;AACpB,UAAIL,KAAK,IAAID,SAAb,EAAwB;AACpB5B,QAAAA,GAAG,CAAC,kCAAD,EAAqC2B,QAArC,CAAH;AACAK,QAAAA,MAAM;AACN;AACH;;AACD,YAAMG,GAAG,GAAGF,KAAK,EAAjB;;AACA,UAAIE,GAAJ,EAAS;AACLJ,QAAAA,OAAO,CAACI,GAAD,CAAP;AACA;AACH;;AAED5B,MAAAA,MAAM,CAACM,UAAP,CAAkBqB,YAAlB,EAAgC,GAAhC;AACH;;AAEDA,IAAAA,YAAY;AACf,GAtBM,CAAP;AAuBH","sourcesContent":["/**\n * Wrapped console.log function.\n *\n * @export\n * @param {*} args\n */\nexport function log(...args) {\n    console.log(\"Userscript (React Mode):\", ...args);\n}\n\n/**\n * Wrapped version of `fetch` that logs the output as it's being fetched.\n * It also specifies the full path, because in Greasemonkey, the full path is needed.\n *\n * @param {string} arg\n * @returns {Promise} - the `fetch` promise\n */\nexport function logFetch(arg) {\n    const url = new URL(arg, window.location);\n    log(\"fetching\", \"\" + url);\n    return fetch(\"\" + url, { credentials: \"include\" });\n}\n\n/**\n * Ensure `callback` is called every time window.location changes\n * Code derived from https://stackoverflow.com/questions/3522090/event-when-window-location-href-changes\n *\n * @export\n * @param {function} callback - function to be called when URL changes\n * @returns {MutationObserver} - MutationObserver that watches the URL\n */\nexport function addLocationChangeCallback(callback) {\n    // Run the callback once right at the start\n    window.setTimeout(callback, 0);\n\n    // Set up a `MutationObserver` to watch for changes in the URL\n    let oldHref = window.location.href;\n    const body = document.querySelector(\"body\");\n    const observer = new MutationObserver(mutations => {\n        if (mutations.some(() => oldHref !== document.location.href)) {\n            oldHref = document.location.href;\n            callback();\n        }\n    });\n\n    observer.observe(body, { childList: true, subtree: true });\n    return observer;\n}\n\n/**\n * Awaits for an element with the specified `selector` to be found\n * and then returns the selected dom node.\n * This is used to delay rendering a widget until its parent appears.\n *\n * @export\n * @param {string} selector\n * @returns {DOMNode}\n */\nexport async function awaitElement(selector) {\n    const MAX_TRIES = 60;\n    let tries = 0;\n    return new Promise((resolve, reject) => {\n        function probe() {\n            tries++;\n            return document.querySelector(selector);\n        }\n\n        function delayedProbe() {\n            if (tries >= MAX_TRIES) {\n                log(\"Can't find element with selector\", selector);\n                reject();\n                return;\n            }\n            const elm = probe();\n            if (elm) {\n                resolve(elm);\n                return;\n            }\n\n            window.setTimeout(delayedProbe, 250);\n        }\n\n        delayedProbe();\n    });\n}\n"]},"metadata":{},"sourceType":"module"}